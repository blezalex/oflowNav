<html ng-app="oflowNav">
	<head>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }

			#camInput {
				width: 800px;
				height: 600px;
			}

			#flowOutContainer, #flowOut {
				width: 800px;
				height: 600px;
			}

			#camInput, .controlPanel {
				display: inline-block;
				vertical-align: top;
			}

		</style>

		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
	</head>
	<body ng-controller="mainCtrl">
		<div id="camInput"> </div>
		<div class="controlPanel">
			<h3>
				Controls:
			</h3>			
			<p>
				<button ng-click="navigate()" class="btn btn-primary" ng-disabled="runToEnd">Navigate</button>
			</p>

			<p>
				<button ng-click="reset()" class="btn btn-warning">Rebuild</button>
			</p>
			<p>
				Obstacles: <input type="number" ng-model="obstacleCnt">
			</p>
			<div class="alert alert-success" ng-show="missonComplete">Mission complete</div>
		</div>
		
		<div id="flowOutContainer"><canvas id="flowOut" width="800" height="600"></canvas></div>
		<div><span id="magnLeft"></span> <span id="magnRight"></span></div>

		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/angularjs/1.3.8/angular.min.js"></script>
		<script src="js/ext/three.min.js"></script>

		<script src="js/ext/oflow/colors.js"></script>
		<script src="js/ext/oflow/oflow.js"></script>

		<script src="js/navController.js"></script>
		<script src="js/CanvasImageCapturer.js"></script>
		<script src="js/autopilot.js"></script>

		<script type="text/javascript">
			function addObstacles(scene, worldWidth, worldDepth, count) {
				var radius = 0.3;
				var geometry = new THREE.CylinderGeometry(radius, radius, 4);

				var texture = THREE.ImageUtils.loadTexture( "img/lavatile.jpg" );
				texture.repeat.set( 4, 2 );
				texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				texture.anisotropy = 16;
				var material = new THREE.MeshLambertMaterial( { map: texture, color: 0xFFff00, ambient: 0x999999, shading: THREE.SmoothShading } );

				for (var i = 0; i < count; i++)
				{
					var cylinder = new THREE.Mesh(geometry, material ); 

					cylinder.position.y = 0.5;

					cylinder.position.x = Math.random() * worldWidth - worldWidth / 2;
					cylinder.position.z = Math.random() * worldDepth - worldDepth / 2;

					scene.add( cylinder );
				}
			}

			function addFloor(scene, worldWidth, worldDepth) {
				var planeG = new THREE.PlaneGeometry( worldWidth, worldDepth); 
				var material = new THREE.MeshLambertMaterial( {color: 0xffff00, side: THREE.DoubleSide} ); 
				var plane = new THREE.Mesh( planeG, material ); 
				plane.rotation.x = Math.PI /2
				scene.add( plane );
			}

			function addLights(scene) {
				var light = new THREE.PointLight( 0xffffff, 1, 100 ); 
				light.position.set( 4, 6, -4 ); 
				scene.add( light );

				var alight = new THREE.AmbientLight( 0x505050 ); // soft white light 
				scene.add( alight );
			}

			function addGoal(scene, position) {
				var geometry = new THREE.SphereGeometry( 0.4, 32, 32 ); 
				var material = new THREE.MeshLambertMaterial( {color: 0x00ff00} ); 
				var sphere = new THREE.Mesh( geometry, material ); 
				sphere.position.copy(position);
				scene.add( sphere );
			}

			function setupWorld(camera, worldWidth, worldDepth, goalPostion, obstacleCnt){
				var scene = new THREE.Scene();

				addLights(scene);
				addFloor(scene, worldWidth, worldDepth);
				addObstacles(scene, worldWidth, worldDepth, obstacleCnt)			
				addGoal(scene, goalPostion);

				//== position camera ==
				camera.position.x = -worldWidth / 2 / 2;
				camera.position.z = -worldDepth / 2 / 2;

				return scene;
			}

			function goalReached(currentPostion, goalPostion) {
				return currentPostion.distanceTo(goalPostion) < 2;
			}

			var app = angular.module("oflowNav", []);

			app.controller('mainCtrl', ['$scope', function($scope){
				var rendererParrentDomElement = document.getElementById('camInput');
				var renderer = new THREE.WebGLRenderer( { preserveDrawingBuffer: true });
				renderer.setSize( rendererParrentDomElement.clientWidth, rendererParrentDomElement.clientHeight );
				rendererParrentDomElement.appendChild( renderer.domElement );

				var camera = new THREE.PerspectiveCamera( 75, rendererParrentDomElement.clientWidth/rendererParrentDomElement.clientHeight, 0.1, 1000 );
				
				// center of the world is in 0,0 
				var worldWidth = 50;
				var worldDepth = 50;

				var goalPostion = new THREE.Vector3(worldWidth / 2, 0, worldDepth / 2); // goal is at the end of the world
				var scene;

				var autopilot = new Autopilot(renderer.domElement, document.getElementById('flowOut'));
				autopilot.setTarget(goalPostion);

				var cameraLookDirection = new THREE.Vector3(0, 0, 1);
				var nav = new NavController(camera, document.body, 0.1, 0.02, goalPostion, autopilot);

				var render = function () {
					requestAnimationFrame( render );

					renderer.render(scene, camera);

					if (!$scope.runToEnd)
						nav.processInput(cameraLookDirection);
					else
					{
						var nextStep = autopilot.getNextStep(cameraLookDirection, camera.position);

						camera.position.add(nextStep[0]);
						cameraLookDirection.copy(nextStep[1]);
						
						var currentLookDirection = new THREE.Vector3().addVectors(camera.position, cameraLookDirection);
						camera.lookAt(currentLookDirection);

						if (goalReached(camera.position, goalPostion)) {
							$scope.$apply(function(){
								$scope.runToEnd = false;
								$scope.missonComplete = true;
							});
						}
					}
				};

				
				$scope.obstacleCnt = 200;

				$scope.reset = function() {
					$scope.runToEnd = false;
					$scope.missonComplete = false;
					scene = setupWorld(camera, worldWidth, worldDepth, goalPostion, $scope.obstacleCnt);
				}

				$scope.reset();

				$scope.navigate = function() {
					$scope.runToEnd = true;
				}

				render();
			}]);

		</script>
	</body>
</html>