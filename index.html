<html>
	<head>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }

			#camInput {
				width: 800px;
				height: 600px;
			}

			#flowOutContainer, #flowOut {
				width: 800px;
				height: 600px;
			}

		</style>
	</head>
	<body>
		<div id="camInput"> </div>
		<div id="flowOutContainer"><canvas id="flowOut" width="800" height="600"></canvas></div>
		<div><span id="magnLeft"></span> <span id="magnRight"></span></div>

		<script src="js/ext/three.min.js"></script>
		<script src="js/ext/Projector.js"></script>
		<script src="js/ext/CanvasRenderer.js"></script>
		<script src="js/ext/oflow/flowZone.js"></script>
		<script src="js/ext/oflow/flowCalculator.js"></script>
		<script src="js/ext/oflow/colors.js"></script>

		<script src="js/navController.js"></script>
		<script>
			var rendererParrentDomElement = document.getElementById("camInput");

			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, rendererParrentDomElement.clientWidth/rendererParrentDomElement.clientHeight, 0.1, 1000 );

			var renderer = new THREE.WebGLRenderer( {     preserveDrawingBuffer: true  });
			//var renderer = new THREE.CanvasRenderer();

			renderer.setSize( rendererParrentDomElement.clientWidth, rendererParrentDomElement.clientHeight );
			rendererParrentDomElement.appendChild( renderer.domElement );

			var light = new THREE.PointLight( 0xffffff, 1, 100 ); 
			light.position.set( 4, 6, -4 ); 
			scene.add( light );

			var alight = new THREE.AmbientLight( 0x505050 ); // soft white light 
			scene.add( alight );

			var planeG = new THREE.PlaneGeometry( 50, 50); 
			var material = new THREE.MeshLambertMaterial( {color: 0xffff00, side: THREE.DoubleSide} ); 
			var plane = new THREE.Mesh( planeG, material ); 
			plane.rotation.x = Math.PI /2
			scene.add( plane );

			var cylinderRadius = 0.3;
			var cylinderG = new THREE.CylinderGeometry(cylinderRadius, cylinderRadius, 4);

			var imgTexture = THREE.ImageUtils.loadTexture( "img/lavatile.jpg" );
			imgTexture.repeat.set( 4, 2 );
			imgTexture.wrapS = imgTexture.wrapT = THREE.RepeatWrapping;
			imgTexture.anisotropy = 16;
			var material = new THREE.MeshLambertMaterial( { map: imgTexture, color: 0xFFff00, ambient: 0x999999, shading: THREE.SmoothShading } );

			var xSpread = 48;
			var zSpread = 48;

			for (var i = 0; i < 200; i++)
			{
				var cylinder = new THREE.Mesh( cylinderG, material ); 

				cylinder.position.y = 0.5;

				cylinder.position.x = Math.random() * xSpread - xSpread / 2;
				cylinder.position.z = Math.random() * zSpread - zSpread / 2;


				scene.add( cylinder );
			}

			var goalPostion = [xSpread /2, zSpread / 2];
			camera.position.x = - xSpread /2 / 2;
			camera.position.z = - zSpread /2 / 2;


			var geometry = new THREE.SphereGeometry( 0.4, 32, 32 ); 
			var material = new THREE.MeshLambertMaterial( {color: 0x00ff00} ); 
			var sphere = new THREE.Mesh( geometry, material ); 
			scene.add( sphere );
			sphere.position.x = goalPostion[0];
			sphere.position.z = goalPostion[1];

			
			var nav = new NavController(camera, document.body, 0.1, 0.02, goalPostion);

			var imgCtx = renderer.domElement.getContext('2d');
			var oldImage;
			var width = rendererParrentDomElement.clientWidth;
			var height = rendererParrentDomElement.clientHeight;
			calculator = new FlowCalculator(6);

			var flowOutScene = document.getElementById('flowOut');
			sceneCtx = flowOutScene.getContext('2d');
			var sceneWidth = width;
			var sceneHeight = height;

			var midPoint = width / 2;
			var magnIndicationElements = [document.getElementById("magnLeft"), document.getElementById("magnRight")];
			
			var proxyCanvas = document.createElement("canvas");
			proxyCanvas.setAttribute('height', height);
			proxyCanvas.setAttribute('width', width);

			var proxyContext = proxyCanvas.getContext('2d');

			//  === Observations: ===
			//  1. Alg will hit an obstacles when flow on both sides is equal (may be high), it wont look for path around the obstacles. 
			//  	Should it look for expansion point instead? 

			//  2. Alg makes decision on the stop, no path planning at all

			var magnitudes = [0,0];
			var render = function () {
				requestAnimationFrame( render );

				renderer.render(scene, camera);

				if (nav.processInput(magnitudes))	{

			     		proxyContext.drawImage(renderer.domElement, 0, 0);

						var newImage = proxyContext.getImageData(0, 0, width, height);

						magnitudes = [0,0]; // reset magnitudes
						if (newImage && oldImage) {
							var zones = calculator.calculate(oldImage.data, newImage.data, width, height).zones;
 							sceneCtx.clearRect(0, 0, sceneWidth, sceneHeight);

							for(var i = 0; i < zones.length; ++i) {
								var zone = zones[i];
								magnitudes[zone.x > midPoint ? 1 : 0] += Math.abs(zone.u) + Math.abs(zone.v);

								sceneCtx.strokeStyle = getDirectionalColor(zone.u, zone.v);
								sceneCtx.beginPath();
								sceneCtx.moveTo(zone.x,zone.y);
								sceneCtx.lineTo((zone.x - zone.u), zone.y + zone.v);
								sceneCtx.stroke();
							}

							for (var i = 0; i < magnitudes.length; i++)
							{
								magnIndicationElements[i].innerText = magnitudes[i];
							}
							
						}
						oldImage = newImage;
				}
			};

			render();
		</script>
	</body>
</html>