<html>
	<head>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }

			#camInput {
				width: 800px;
				height: 600px;
			}

			#flowOutContainer, #flowOut {
				width: 800px;
				height: 600px;
			}

		</style>
	</head>
	<body>
		<div id="camInput"> </div>
		<div id="flowOutContainer"><canvas id="flowOut" width="800" height="600"></canvas></div>
		<div><span id="magnLeft"></span> <span id="magnRight"></span></div>

		<script src="js/ext/three.min.js"></script>

		<script src="js/ext/oflow/colors.js"></script>
		<script src="js/ext/oflow/oflow.js"></script>

		<script src="js/navController.js"></script>
		<script src="js/CanvasImageCapturer.js"></script>

		<script>

			function addObstacles(scene, worldWidth, worldDepth, count) {
				var radius = 0.3;
				var geometry = new THREE.CylinderGeometry(radius, radius, 4);

				var texture = THREE.ImageUtils.loadTexture( "img/lavatile.jpg" );
				texture.repeat.set( 4, 2 );
				texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				texture.anisotropy = 16;
				var material = new THREE.MeshLambertMaterial( { map: texture, color: 0xFFff00, ambient: 0x999999, shading: THREE.SmoothShading } );

				for (var i = 0; i < count; i++)
				{
					var cylinder = new THREE.Mesh(geometry, material ); 

					cylinder.position.y = 0.5;

					cylinder.position.x = Math.random() * worldWidth - worldWidth / 2;
					cylinder.position.z = Math.random() * worldDepth - worldDepth / 2;

					scene.add( cylinder );
				}
			}

			function addFloor(scene, worldWidth, worldDepth) {
				var planeG = new THREE.PlaneGeometry( worldWidth, worldDepth); 
				var material = new THREE.MeshLambertMaterial( {color: 0xffff00, side: THREE.DoubleSide} ); 
				var plane = new THREE.Mesh( planeG, material ); 
				plane.rotation.x = Math.PI /2
				scene.add( plane );
			}

			function addLights(scene) {
				var light = new THREE.PointLight( 0xffffff, 1, 100 ); 
				light.position.set( 4, 6, -4 ); 
				scene.add( light );

				var alight = new THREE.AmbientLight( 0x505050 ); // soft white light 
				scene.add( alight );
			}

			function addGoal(scene, position) {
				var geometry = new THREE.SphereGeometry( 0.4, 32, 32 ); 
				var material = new THREE.MeshLambertMaterial( {color: 0x00ff00} ); 
				var sphere = new THREE.Mesh( geometry, material ); 
				sphere.position.copy(position);
				scene.add( sphere );
			}

			// center of the world is in 0,0 
			var worldWidth = 50;
			var worldDepth = 50;

			var rendererParrentDomElement = document.getElementById("camInput");
			var renderer = new THREE.WebGLRenderer( { preserveDrawingBuffer: true });
			renderer.setSize( rendererParrentDomElement.clientWidth, rendererParrentDomElement.clientHeight );
			rendererParrentDomElement.appendChild( renderer.domElement );

			var camera = new THREE.PerspectiveCamera( 75, rendererParrentDomElement.clientWidth/rendererParrentDomElement.clientHeight, 0.1, 1000 );
			var scene = new THREE.Scene();

			addLights(scene);
			addFloor(scene, worldWidth, worldDepth);

			addObstacles(scene, worldWidth, worldDepth, 200)

			//==  goal  ==
			var goalPostion = new THREE.Vector3(worldWidth / 2, 0, worldDepth / 2); // goal is at the end of the world
			addGoal(scene, goalPostion);

			//== position camera ==
			camera.position.x = -worldWidth / 2 / 2;
			camera.position.z = -worldDepth / 2 / 2;


			var nav = new NavController(camera, document.body, 0.1, 0.02, goalPostion);

			var oldImage;
			var width = rendererParrentDomElement.clientWidth;
			var height = rendererParrentDomElement.clientHeight;
			calculator = new oflow.FlowCalculator(6);

			sceneCtx = document.getElementById('flowOut').getContext('2d');

			var midPoint = width / 2;
			var magnIndicationElements = [document.getElementById("magnLeft"), document.getElementById("magnRight")];
			
			var imgCapturer = new CanvasImageCapturer(renderer.domElement);


			//  === Observations: ===
			//  1. Alg will hit an obstacles when flow on both sides is equal (may be high), it wont look for path around the obstacles. 
			//  	Should it look for expansion point instead? 

			//  2. Alg makes decision on the stop, no path planning at all

			var magnitudes = [0,0];
			var render = function () {
				requestAnimationFrame( render );

				renderer.render(scene, camera);

				if (nav.processInput(magnitudes))	{
						var newImage = imgCapturer.getImageData();

						magnitudes = [0,0]; // reset magnitudes
						if (newImage && oldImage) {
							var zones = calculator.calculate(oldImage.data, newImage.data, width, height).zones;
 							sceneCtx.clearRect(0, 0, width, height);

							for(var i = 0; i < zones.length; ++i) {
								var zone = zones[i];
								magnitudes[zone.x > midPoint ? 1 : 0] += Math.abs(zone.u) + Math.abs(zone.v);

								sceneCtx.strokeStyle = getDirectionalColor(zone.u, zone.v);
								sceneCtx.beginPath();
								sceneCtx.moveTo(zone.x,zone.y);
								sceneCtx.lineTo((zone.x - zone.u), zone.y + zone.v);
								sceneCtx.stroke();
							}

							for (var i = 0; i < magnitudes.length; i++)
							{
								magnIndicationElements[i].innerText = magnitudes[i];
							}
							
						}
						oldImage = newImage;
				}
			};

			render();
		</script>
	</body>
</html>