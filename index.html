<html>
	<head>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }

			#camInput {
				width: 800px;
				height: 600px;
			}

			#flowOutContainer, #flowOut {
				width: 800px;
				height: 600px;
			}

		</style>
	</head>
	<body>
		<div id="camInput"> </div>
		<div id="flowOutContainer"><canvas id="flowOut" width="800" height="600"></canvas></div>
		<div><span id="magnLeft"></span> <span id="magnRight"></span></div>

		<script src="js/ext/three.min.js"></script>
		<script src="js/ext/Projector.js"></script>
		<script src="js/ext/CanvasRenderer.js"></script>
		<script src="js/ext/oflow/flowzone.js"></script>
		<script src="js/ext/oflow/flowCalculator.js"></script>
		<script src="js/ext/oflow/colors.js"></script>

		<script src="js/navController.js"></script>
		<script>
			var rendererParrentDomElement = document.getElementById("camInput");

			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, rendererParrentDomElement.clientWidth/rendererParrentDomElement.clientHeight, 0.1, 1000 );

			//var renderer = new THREE.WebGLRenderer( {     preserveDrawingBuffer: true  });
			var renderer = new THREE.CanvasRenderer();

			renderer.setSize( rendererParrentDomElement.clientWidth, rendererParrentDomElement.clientHeight );
			rendererParrentDomElement.appendChild( renderer.domElement );

			var light = new THREE.PointLight( 0xffffff, 1, 100 ); 
			light.position.set( 5, 5, -5 ); 
			scene.add( light );

			var alight = new THREE.AmbientLight( 0x202020 ); // soft white light 
			scene.add( alight );

			var planeG = new THREE.PlaneGeometry( 50, 50); 
			var material = new THREE.MeshLambertMaterial( {color: 0xffff00, side: THREE.DoubleSide} ); 
			var plane = new THREE.Mesh( planeG, material ); 
			plane.rotation.x = Math.PI /2
			scene.add( plane );

			var cylinderRadius = 0.3;
			var cylinderG = new THREE.CylinderGeometry(cylinderRadius, cylinderRadius, 4);

			var imgTexture = THREE.ImageUtils.loadTexture( "img/lavatile.jpg" );
			imgTexture.repeat.set( 4, 2 );
			imgTexture.wrapS = imgTexture.wrapT = THREE.RepeatWrapping;
			imgTexture.anisotropy = 16;
			var material = new THREE.MeshLambertMaterial( { map: imgTexture, color: 0xFFff00, ambient: 0x777777, shading: THREE.SmoothShading } );

			var xSpread = 24;
			var zSpread = 24;

			for (var i = 0; i < 60; i++)
			{
				var cylinder = new THREE.Mesh( cylinderG, material ); 

				cylinder.position.y = 0.5;

				cylinder.position.x = Math.random() * xSpread - xSpread / 2;
				cylinder.position.z = Math.random() * zSpread - zSpread / 2;


				scene.add( cylinder );
			}

			
			var nav = new NavController(camera, document.body, 0.1, 0.02);

			var imgCtx = renderer.domElement.getContext('2d');
			var oldImage;
			var width = rendererParrentDomElement.clientWidth;
			var height = rendererParrentDomElement.clientHeight;
			calculator = new FlowCalculator(8);

			var flowOutScene = document.getElementById('flowOut');
			sceneCtx = flowOutScene.getContext('2d');
			var sceneWidth = width;
			var sceneHeight = height;

			var midPoint = width / 2;
			var magnIndicationElements = [document.getElementById("magnLeft"), document.getElementById("magnRight")];
			
			var magnitudes = [0,0];
			var render = function () {
				requestAnimationFrame( render );

				renderer.render(scene, camera);

				if (nav.processInput(magnitudes))	{
					var newImage = imgCtx.getImageData(0, 0, width, height);

				magnitudes = [0,0]; // reset magnitudes
				if (newImage && oldImage) {
					var zones = calculator.calculate(oldImage.data, newImage.data, width, height).zones;

					sceneCtx.clearRect(0, 0, sceneWidth, sceneHeight);

					for(var i = 0; i < zones.length; ++i) {
						var zone = zones[i];
						magnitudes[zone.x > midPoint ? 1 : 0] += Math.abs(zone.u) + Math.abs(zone.v);

						sceneCtx.strokeStyle = getDirectionalColor(zone.u, zone.v);
						sceneCtx.beginPath();
						sceneCtx.moveTo(zone.x,zone.y);
						sceneCtx.lineTo((zone.x - zone.u), zone.y + zone.v);
						sceneCtx.stroke();
					}

					for (var i = 0; i < magnitudes.length; i++)
					{
						magnIndicationElements[i].innerText = magnitudes[i];
					}
					
				}

				}

				oldImage = newImage;
			};

			render();
		</script>
	</body>
</html>